#pragma config(Sensor, dgtl1,  chassis_rtQuad, sensorQuadEncoder)
<<<<<<< HEAD
#pragma config(Sensor, dgtl3,  chassis_ltQuad, sensorQuadEncoder)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           rearRight,     tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port4,           frontLeft,     tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port5,           rearLeft,      tmotorVex393_MC29, openLoop, reversed, driveLeft)
=======
#pragma config(Motor,  port1,           right,         tmotorVex393_HBridge, openLoop)
>>>>>>> 936e1dc34661150554eec5d125eef3e9a40a8ef9
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/***********************/
/*Competition Libraries*/
/***********************/

#pragma platform(VEX2)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"


/******************/
/*Global Variables*/
/******************/

bool inAuto = false;


/************************/
/* Normal Drive Methods */
/************************/

void straightDrive(float speed) {
	//Allows for the speed input to be percentages (0-100)
	speed *= 1.2;
	motor[frontRight] = speed;
	motor[rearRight] = speed;
	motor[frontLeft] = -speed;
	motor[rearLeft] = -speed;
}

void turn(float speed) {
	//Positive: Turn Left
	//Negative: Turn Right
	speed *= 1.2;
	motor[frontRight] = speed;
	motor[rearRight] = speed;
	motor[frontLeft] = speed;
	motor[rearLeft] = speed;
}

void stopDrive() {
	motor[frontRight] = 0;
	motor[rearRight] = 0;
	motor[frontLeft] = 0;
	motor[rearLeft] = 0;
}

float getRightEncoder() {
	return SensorValue[chassis_rtQuad];
}
float getLeftEncoder() {
	return SensorValue[chassis_ltQuad];
}

<<<<<<< HEAD

/*********************/
/* PID Drive Methods */
/*********************/




/****************************/
/*										 			*/
/* ------ Auton Code ------ */
/*													*/
/****************************/

void pre_auton() {

	SensorValue[chassis_rtQuad] = 0;
	SensorValue[chassis_ltQuad] = 0;

	bStopTasksBetweenModes = true;

	// Example: clearing encoders, setting servo positions, ...
}


task autonomous() {
	inAuto = true;
	while(inAuto) {
		straightDrive(100);
		if(getRightEncoder() == 1000 && getLeftEncoder() == 1000) {
			stopDrive();
			} else {
			straightDrive(100);
		}
		turn(100);

	}
}


/*****************************/
/*													 */
/* ------ Teleop Code ------ */
/*													 */
/*****************************/

task usercontrol() {

	while (true)
	{
		motor[frontRight] = vexRT[Ch2];
		motor[rearRight] = vexRT[Ch2];
		motor[frontLeft] = vexRT[Ch3];
		motor[rearLeft] = vexRT[Ch3];
	}
=======
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
  // User control code here, inside the loop

  while (true)
  {
    motor(right) = vexRT[Ch1];
  }
>>>>>>> 936e1dc34661150554eec5d125eef3e9a40a8ef9
}
